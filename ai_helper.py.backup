"""
AIæ–‡ç« ç”Ÿæˆã‚¢ã‚·ã‚¹ãƒˆãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
grok-4-1-fast-reasoningã‚’ä½¿ç”¨ã—ãŸæ–‡ç« ç”Ÿæˆæ©Ÿèƒ½
Gemini 3 Flash Previewã‚’ä½¿ç”¨ã—ãŸéŸ³å£°èªè­˜ã¨è­°äº‹éŒ²ç”Ÿæˆæ©Ÿèƒ½
"""
import os
from typing import Optional, Dict, Tuple, Any
import requests

try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False


class AIHelper:
    """AIæ–‡ç« ç”Ÿæˆãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹"""
    
    def __init__(self, api_key: Optional[str] = None, gemini_api_key: Optional[str] = None):
        """
        åˆæœŸåŒ–
        
        Args:
            api_key: Grok APIã‚­ãƒ¼ï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ã™ã‚‹å ´åˆã¯Noneï¼‰
            gemini_api_key: Gemini APIã‚­ãƒ¼ï¼ˆç’°å¢ƒå¤‰æ•°ã‹ã‚‰å–å¾—ã™ã‚‹å ´åˆã¯Noneï¼‰
        """
        self.api_key = api_key or os.getenv("GROK_API_KEY")
        self.api_url = "https://api.x.ai/v1/chat/completions"
        self.model = "grok-4-1-fast-reasoning"
        
        # Gemini APIè¨­å®š
        self.gemini_api_key = gemini_api_key or os.getenv("GEMINI_API_KEY")
        if GEMINI_AVAILABLE and self.gemini_api_key:
            genai.configure(api_key=self.gemini_api_key)
    
    def is_available(self) -> bool:
        """APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        return self.api_key is not None and self.api_key.strip() != ""
    
    def generate_report_text(self, keywords: str, child_name: Optional[str] = None) -> tuple:
        """
        ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰æ—¥å ±å½¢å¼ã®æ–‡ç« ã‚’ç”Ÿæˆ
        
        Args:
            keywords: ç®‡æ¡æ›¸ãã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            child_name: å…ç«¥åï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, ç”Ÿæˆã•ã‚ŒãŸæ–‡ç« )
        """
        if not self.is_available():
            return False, "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not keywords or not keywords.strip():
            return False, "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        # å…ç«¥åã®è¨­å®šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ã€Œã€‡ã€‡ã•ã‚“ã€ï¼‰
        display_name = f"{child_name}ã•ã‚“" if child_name else "ã€‡ã€‡ã•ã‚“"
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
        prompt = f"""#å‘½ä»¤æ›¸ : 
ã‚ãªãŸã¯ã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªã€ãƒ—ãƒ­ã®æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã€å…ç«¥ç™ºé”æ”¯æ´ã®å…ç«¥æŒ‡å°å“¡ã§ã‚ã‚Šã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªèªçŸ¥ç§‘å­¦è€…ã§ã‚ã‚Šã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªãƒ—ãƒ­ã®ç™‚è‚²ã®å°‚é–€å®¶ã§ã‚ã‚Šã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªãƒ—ãƒ­ã®æƒ…å ±åˆ†æå®˜ã§ã™ã€‚æ”¾èª²å¾Œãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã€å…ç«¥ç™ºé”æ”¯æ´ã®æœ€é«˜ã®æ”¯æ´è¨˜éŒ²ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚ä»¥ä¸‹ã®è¦ä»¶ã«åŸºã¥ã„ã¦ã€å…¥åŠ›ã—ãŸã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰æ°—ã¥ã„ãŸã“ã¨ã‚’æŠ½å‡ºã—ã€ç™‚è‚²çš„ã€èªçŸ¥ç§‘å­¦çš„å´é¢ã‹ã‚‰ãã‚Œã«é–¢ã™ã‚‹ä»Šå¾Œã®æ”¯æ´ç­–ã‚’ä½œæˆã™ã‚‹ã€‚é æ…®ã›ãšã«ã€å…¨åŠ›ã‚’å°½ãã—ã¦ãã ã•ã„ã€‚ç§€é€¸ã«ultrahardã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚

##è¦ä»¶:
ãƒ»æ–‡å­—æ•°ã¯ 300å­—ç¨‹åº¦ 
ãƒ»åˆ©ç”¨è€…ã®åå‰:{display_name}
ãƒ»æ–‡ç« å½¢å¼ã§ç°¡æ½”ã«æ›¸ã
ãƒ»ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã‚‰èª²é¡Œã‚’æŠ½å‡ºã—ã¦ã€è§£æ±ºç­–ã‚’å°ã
ãƒ»ç™‚è‚²çš„ã€èªçŸ¥ç§‘å­¦çš„å´é¢ã‚’åŠ ãˆã‚‹
ãƒ»å¸¸ä½“ã§æ›¸ã

ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:
{keywords}
"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯ã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªã€ãƒ—ãƒ­ã®æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã€å…ç«¥ç™ºé”æ”¯æ´ã®å…ç«¥æŒ‡å°å“¡ã§ã‚ã‚Šã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªèªçŸ¥ç§‘å­¦è€…ã§ã‚ã‚Šã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªãƒ—ãƒ­ã®ç™‚è‚²ã®å°‚é–€å®¶ã§ã‚ã‚Šã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªãƒ—ãƒ­ã®æƒ…å ±åˆ†æå®˜ã§ã™ã€‚æ”¾èª²å¾Œãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã€å…ç«¥ç™ºé”æ”¯æ´ã®æœ€é«˜ã®æ”¯æ´è¨˜éŒ²ã‚’ä½œæˆã™ã‚‹ã®ãŒå¾—æ„ã§ã™ã€‚"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.7,
                "max_tokens": 500
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                generated_text = result["choices"][0]["message"]["content"]
                # 100å­—ä»¥å†…ã«åˆ¶é™
                generated_text = generated_text.strip()
                if len(generated_text) > 100:
                    generated_text = generated_text[:100]
                return True, generated_text
            else:
                error_msg = f"APIã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text}"
                return False, error_msg
                
        except requests.exceptions.Timeout:
            return False, "APIã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
        except requests.exceptions.RequestException as e:
            return False, f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)}"
        except Exception as e:
            return False, f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"
    
    def is_gemini_available(self) -> bool:
        """Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        return GEMINI_AVAILABLE and self.gemini_api_key is not None and self.gemini_api_key.strip() != ""
    
    def _ensure_gemini_configured(self):
        """Gemini APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦è¨­å®šã™ã‚‹"""
        if not GEMINI_AVAILABLE or not self.gemini_api_key:
            return False
        
        try:
            # APIã‚­ãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆä½™åˆ†ãªç©ºç™½ã‚„æ”¹è¡Œã‚’å‰Šé™¤ï¼‰
            api_key = self.gemini_api_key.strip()
            # è¤‡æ•°ã®APIã‚­ãƒ¼ãŒçµåˆã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€æœ€åˆã®æœ‰åŠ¹ãªã‚­ãƒ¼ã®ã¿ã‚’ä½¿ç”¨
            if ' ' in api_key:
                # ã‚¹ãƒšãƒ¼ã‚¹ã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€æœ€åˆã®éƒ¨åˆ†ã®ã¿ã‚’ä½¿ç”¨
                api_key = api_key.split()[0]
            
            # genai.configure()ã‚’å†å‘¼ã³å‡ºã—ã¦ã€æœ€æ–°ã®APIã‚­ãƒ¼ã‚’è¨­å®š
            genai.configure(api_key=api_key)
            self.gemini_api_key = api_key
            return True
        except Exception:
            return False
    
    def transcribe_audio_to_text(self, audio_file_path: str, context_info: Optional[str] = None) -> Tuple[bool, str]:
        """
        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            audio_file_path: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            context_info: è£œåŠ©æƒ…å ±ï¼ˆåå‰ã€å›ºæœ‰åè©ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ãŸãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, å¤‰æ›ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not os.path.exists(audio_file_path):
            return False, "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
        
        # APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        if not self._ensure_gemini_configured():
            return False, "Gemini APIã‚­ãƒ¼ã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
        
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‹ã‚‰MIMEã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            file_ext = os.path.splitext(audio_file_path)[1].lower()
            mime_types = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.ogg': 'audio/ogg',
                '.flac': 'audio/flac',
                '.webm': 'audio/webm'
            }
            mime_type = mime_types.get(file_ext, 'audio/mpeg')
            
            # Gemini 3 Flash Previewã‚’ä½¿ç”¨ã—ã¦éŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
            model = genai.GenerativeModel('gemini-3-flash-preview')
            
            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            audio_file_obj = genai.upload_file(
                path=audio_file_path,
                mime_type=mime_type
            )
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š
            prompt = """ã“ã®éŸ³å£°ã¯æœç¤¼ã®è­°äº‹éŒ²ã§ã™ã€‚éŸ³å£°ã®å†…å®¹ã‚’æ­£ç¢ºã«ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
è©±ã—æ‰‹ã®è¨€è‘‰ã‚’ãã®ã¾ã¾è¨˜éŒ²ã—ã€è¨€ã„ã‚ˆã©ã¿ã‚„ç¹°ã‚Šè¿”ã—ã‚‚å«ã‚ã¦æ­£ç¢ºã«æ›¸ãèµ·ã“ã—ã¦ãã ã•ã„ã€‚
ä¸è¦ãªç·¨é›†ã¯è¡Œã‚ãšã€è©±ã•ã‚ŒãŸå†…å®¹ã‚’å¿ å®Ÿã«è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚"""
            
            # è£œåŠ©æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«è¿½åŠ 
            if context_info and context_info.strip():
                prompt += f"""

ä»¥ä¸‹ã®æƒ…å ±ã‚’å‚è€ƒã«ã—ã¦ã€éŸ³å£°å†…ã®åå‰ã‚„å›ºæœ‰åè©ã®èªè­˜ç²¾åº¦ã‚’å‘ä¸Šã•ã›ã¦ãã ã•ã„ï¼š
{context_info}

ã“ã‚Œã‚‰ã®æƒ…å ±ã‚’å‚è€ƒã«ã—ãªãŒã‚‰ã€éŸ³å£°ã®å†…å®¹ã‚’æ­£ç¢ºã«ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"""
            
            # éŸ³å£°èªè­˜ã‚’å®Ÿè¡Œ
            response = model.generate_content([prompt, audio_file_obj])
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            transcribed_text = response.text.strip()
            
            # ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
            genai.delete_file(audio_file_obj.name)
            
            return True, transcribed_text
            
        except Exception as e:
            return False, f"éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def generate_meeting_minutes_from_audio(self, audio_file_path: str, context_info: Optional[str] = None) -> Tuple[bool, Dict[str, str]]:
        """
        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœç¤¼è­°äº‹éŒ²ã‚’ç”Ÿæˆï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            audio_file_path: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            context_info: è£œåŠ©æƒ…å ±ï¼ˆåå‰ã€å›ºæœ‰åè©ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ãŸãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, è­°äº‹éŒ²ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not os.path.exists(audio_file_path):
            return False, "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
        
        try:
            # ã¾ãšéŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆè£œåŠ©æƒ…å ±ã‚’å«ã‚ã‚‹ï¼‰
            success, transcribed_text = self.transcribe_audio_to_text(audio_file_path, context_info)
            if not success:
                return False, transcribed_text
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰è­°äº‹éŒ²ã‚’æ§‹é€ åŒ–
            return self.generate_meeting_minutes_from_text(transcribed_text)
            
        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def ensure_title_format(self, title: str, source_text: str = "") -> str:
        """
        ã‚¿ã‚¤ãƒˆãƒ«ãŒå¿…ãšã€Œã®ä»¶ã€å½¢å¼ã«ãªã‚‹ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ï¼ˆæœ€çµ‚çš„ãªå¼·åˆ¶å‡¦ç†ï¼‰
        
        Args:
            title: å‡¦ç†å‰ã®ã‚¿ã‚¤ãƒˆãƒ«
            source_text: å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
            
        Returns:
            ã€Œã®ä»¶ã€å½¢å¼ã§çµ‚ã‚ã‚‹ã‚¿ã‚¤ãƒˆãƒ«
        """
        if not title or not title.strip():
            # ã‚¿ã‚¤ãƒˆãƒ«ãŒç©ºã®å ´åˆã¯ã€å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç”Ÿæˆ
            if source_text:
                title = source_text.strip()[:18]
                for delimiter in ['ã€‚', 'ã€', '\n', '.', ',', 'ï¼š', ':', 'ãƒ»', 'ã«ã¤ã„ã¦', 'ã«é–¢ã—ã¦']:
                    if delimiter in title:
                        title = title.split(delimiter)[0]
                        break
            else:
                title = "è­°äº‹éŒ²ã®ä»¶"
        
        # ä½™åˆ†ãªæ–‡å­—ã‚’å‰Šé™¤
        title = title.strip()
        title = title.replace('"', '').replace("'", '').replace('ã€Œ', '').replace('ã€', '').replace('ã€', '').replace('ã€‘', '').replace('ï¼ˆ', '').replace('ï¼‰', '').replace('(', '').replace(')', '')
        title = ' '.join(title.split())
        title = title.replace('\n', '').replace('\r', '').replace('\t', '')
        
        # èª¬æ˜æ–‡ã‚„è£œè¶³ã‚’å‰Šé™¤
        for marker in ['ä¾‹:', 'æ³¨æ„:', 'å‡ºåŠ›:', 'ã‚¿ã‚¤ãƒˆãƒ«:', 'ä»¶å:', 'ä»¶:', 'ï¼š', ':', 'å‡ºåŠ›ä¾‹', 'ä¾‹æ–‡']:
            if marker in title:
                title = title.split(marker)[-1].strip()
        
        # ã€Œã®ä»¶ã€ãŒé€”ä¸­ã«ã‚ã‚‹å ´åˆã¯ã€ãã®å‰ã®éƒ¨åˆ†ã‚’å–å¾—
        if "ã®ä»¶" in title and not title.endswith("ã®ä»¶"):
            parts = title.split("ã®ä»¶")
            if parts[0]:
                title = parts[0] + "ã®ä»¶"
            else:
                title = "ã®ä»¶"
        
        # 20æ–‡å­—ä»¥å†…ã«åˆ¶é™ï¼ˆã€Œã®ä»¶ã€ã‚’å«ã‚€ï¼‰
        if len(title) > 20:
            if title.endswith("ã®ä»¶"):
                main_part = title[:-2]
                if len(main_part) > 18:
                    main_part = main_part[:18]
                title = main_part + "ã®ä»¶"
            else:
                title = title[:18] + "ã®ä»¶"
        
        # æœ€çµ‚ç¢ºèª: å¿…ãšã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‹ã“ã¨ã‚’å¼·åˆ¶
        if not title.endswith("ã®ä»¶"):
            # ã€Œã®ä»¶ã€ã‚’é™¤ã„ãŸéƒ¨åˆ†ã‚’å–å¾—
            if "ã®ä»¶" in title:
                title = title.split("ã®ä»¶")[0] + "ã®ä»¶"
            else:
                title = title + "ã®ä»¶"
        
        # ç©ºæ–‡å­—åˆ—ã‚„ã€Œã®ä»¶ã€ã ã‘ã®å ´åˆã¯ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        if not title or title == "ã®ä»¶" or len(title) < 3:
            if source_text:
                fallback = source_text.strip()[:18]
                for delimiter in ['ã€‚', 'ã€', '\n', '.', ',', 'ï¼š', ':', 'ãƒ»', 'ã«ã¤ã„ã¦', 'ã«é–¢ã—ã¦']:
                    if delimiter in fallback:
                        fallback = fallback.split(delimiter)[0]
                        break
                title = fallback + "ã®ä»¶" if fallback else "è­°äº‹éŒ²ã®ä»¶"
            else:
                title = "è­°äº‹éŒ²ã®ä»¶"
        
        return title
    
    def generate_title_from_text(self, text: str) -> tuple:
        """
        ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰çŸ­ã„ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆã€Œâ—‹â—‹ã®ä»¶ã€å½¢å¼ï¼‰
        
        Args:
            text: å…ƒã¨ãªã‚‹ãƒ†ã‚­ã‚¹ãƒˆï¼ˆè­°é¡Œãƒ»å†…å®¹ãªã©ï¼‰
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, ç”Ÿæˆã•ã‚ŒãŸã‚¿ã‚¤ãƒˆãƒ«)
        """
        if not self.is_available():
            # APIã‚­ãƒ¼ãŒãªã„å ´åˆã¯ã€ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ç°¡æ˜“çš„ã«ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆå¿…ãšã€Œã®ä»¶ã€å½¢å¼ï¼‰
            if not text or not text.strip():
                return False, ""
            
            # ãƒ†ã‚­ã‚¹ãƒˆã®æœ€åˆã®18æ–‡å­—ç¨‹åº¦ã‚’å–å¾—
            title = text.strip()[:18]
            # å¥èª­ç‚¹ã‚„æ”¹è¡Œã§åŒºåˆ‡ã‚‹
            for delimiter in ['ã€‚', 'ã€', '\n', '.', ',', 'ï¼š', ':', 'ãƒ»', 'ã«ã¤ã„ã¦', 'ã«é–¢ã—ã¦']:
                if delimiter in title:
                    title = title.split(delimiter)[0]
                    break
            
            # å¼·åˆ¶çš„ã«ã€Œã®ä»¶ã€å½¢å¼ã«å¤‰æ›ï¼ˆæœ€çµ‚çš„ãªä¿è¨¼ï¼‰
            title = self.ensure_title_format(title, text.strip())
            
            return True, title
        
        if not text or not text.strip():
            return False, ""
        
        # ãƒ†ã‚­ã‚¹ãƒˆã‚’å‰å‡¦ç†ï¼ˆæœ€åˆã®100æ–‡å­—ç¨‹åº¦ã‚’å–å¾—ï¼‰
        text_preview = text.strip()[:100]
        for delimiter in ['ã€‚', 'ã€', '\n', '.', ',', 'ï¼š', ':', 'ãƒ»', 'ã«ã¤ã„ã¦', 'ã«é–¢ã—ã¦']:
            if delimiter in text_preview:
                text_preview = text_preview.split(delimiter)[0]
                break
        
        prompt = f"""#å‘½ä»¤æ›¸ï¼ˆçµ¶å¯¾éµå®ˆãƒ»é•åä¸å¯ï¼‰
ã‚ãªãŸã¯ã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªã€ãƒ—ãƒ­ã®ã‚¿ã‚¤ãƒˆãƒ«ç”Ÿæˆã®å°‚é–€å®¶ã§ã™ã€‚é æ…®ã›ãšã«ã€å…¨åŠ›ã‚’å°½ãã—ã¦ãã ã•ã„ã€‚ç§€é€¸ã«ultrahardã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚

##æœ€é‡è¦ãƒ«ãƒ¼ãƒ«ï¼ˆçµ¶å¯¾éµå®ˆãƒ»é•åä¸å¯ï¼‰:
1. å‡ºåŠ›ã¯å¿…ãšã€Œâ—‹â—‹ã®ä»¶ã€ã¨ã„ã†å½¢å¼ã§çµ‚ã‚ã‚‹ã“ã¨ï¼ˆã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‰ãªã„å ´åˆã¯ç„¡åŠ¹ãƒ»çµ¶å¯¾ç¦æ­¢ï¼‰
2. ã€Œã®ä»¶ã€ä»¥å¤–ã®æ–‡å­—åˆ—ã¯ä¸€åˆ‡è¿”ã•ãªã„ã“ã¨ï¼ˆèª¬æ˜æ–‡ã€è£œè¶³ã€ä¾‹ã€æ³¨æ„æ›¸ãã¯ä¸€åˆ‡ä¸è¦ï¼‰
3. ã‚¿ã‚¤ãƒˆãƒ«ã®ã¿ã‚’è¿”ã™ã“ã¨ï¼ˆå¼•ç”¨ç¬¦ã€æ‹¬å¼§ã€æ”¹è¡Œã€ç©ºç™½è¡Œã¯ä¸€åˆ‡ä¸è¦ï¼‰
4. 20æ–‡å­—ä»¥å†…ï¼ˆã€Œã®ä»¶ã€ã‚’å«ã‚€ï¼‰ã«ã¾ã¨ã‚ã‚‹ã“ã¨

##å…¥åŠ›è­°é¡Œãƒ»å†…å®¹:
{text}

##æ­£ã—ã„å‡ºåŠ›ä¾‹ï¼ˆã“ã®å½¢å¼ã®ã¿æœ‰åŠ¹ãƒ»å¿…ãšã“ã®å½¢å¼ã§è¿”ã™ã“ã¨ï¼‰:
åˆ©ç”¨è€…é€è¿ã«é–¢ã™ã‚‹ä»¶
ã‚¹ã‚¿ãƒƒãƒ•ä¼šè­°ã®ä»¶
è¨­å‚™ç‚¹æ¤œã®ä»¶
å®‰å…¨ç¢ºèªã®ä»¶
åˆ©ç”¨è€…å¯¾å¿œã®ä»¶
é€è¿æ¥­å‹™ã®ä»¶

##é–“é•ã£ãŸå‡ºåŠ›ä¾‹ï¼ˆçµ¶å¯¾ã«è¿”ã•ãªã„ã“ã¨ï¼‰:
åˆ©ç”¨è€…é€è¿ã«ã¤ã„ã¦
ã‚¹ã‚¿ãƒƒãƒ•ä¼šè­°
è¨­å‚™ç‚¹æ¤œã«é–¢ã™ã‚‹å ±å‘Š
å®‰å…¨ç¢ºèªã«ã¤ã„ã¦ã®ä»¶å
ã€Œåˆ©ç”¨è€…é€è¿ã®ä»¶ã€
ã€ã‚¹ã‚¿ãƒƒãƒ•ä¼šè­°ã®ä»¶ã€‘

##ç¦æ­¢äº‹é …ï¼ˆçµ¶å¯¾ã«å®ˆã‚‹ã“ã¨ãƒ»é•åä¸å¯ï¼‰:
- ã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‰ãªã„ã‚¿ã‚¤ãƒˆãƒ«ã¯è¿”ã•ãªã„ï¼ˆçµ¶å¯¾ç¦æ­¢ï¼‰
- èª¬æ˜æ–‡ã‚„è£œè¶³ã‚’ä»˜ã‘ãªã„ï¼ˆçµ¶å¯¾ç¦æ­¢ï¼‰
- å¼•ç”¨ç¬¦ã‚„æ‹¬å¼§ã§å›²ã¾ãªã„ï¼ˆçµ¶å¯¾ç¦æ­¢ï¼‰
- æ”¹è¡Œã‚’å…¥ã‚Œãªã„ï¼ˆçµ¶å¯¾ç¦æ­¢ï¼‰
- ã€Œã«ã¤ã„ã¦ã€ã€Œã«é–¢ã—ã¦ã€ãªã©ã®èªå°¾ã¯ä½¿ã‚ãªã„ï¼ˆã€Œã®ä»¶ã€ã®ã¿ä½¿ç”¨ï¼‰

##å‡ºåŠ›æŒ‡ç¤º:
ä¸Šè¨˜ã®æ­£ã—ã„å‡ºåŠ›ä¾‹ã®å½¢å¼ã§ã€ã‚¿ã‚¤ãƒˆãƒ«ã®ã¿ã‚’ã€Œâ—‹â—‹ã®ä»¶ã€å½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ã€‚
è­°é¡Œãƒ»å†…å®¹ã‹ã‚‰é‡è¦ãªã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’æŠ½å‡ºã—ã€ã€Œâ—‹â—‹ã®ä»¶ã€ã¨ã„ã†å½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ã€‚"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯ã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§å„ªç§€ãªã€ãƒ—ãƒ­ã®ã‚¿ã‚¤ãƒˆãƒ«ç”Ÿæˆã®å°‚é–€å®¶ã§ã™ã€‚è­°é¡Œãƒ»å†…å®¹ã‹ã‚‰å¿…ãšã€Œâ—‹â—‹ã®ä»¶ã€ã¨ã„ã†å½¢å¼ã®ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆã—ã¾ã™ã€‚é æ…®ã›ãšã«ã€å…¨åŠ›ã‚’å°½ãã—ã¦ãã ã•ã„ã€‚ç§€é€¸ã«ultrahardã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚\n\næœ€é‡è¦ãƒ«ãƒ¼ãƒ«ï¼ˆçµ¶å¯¾éµå®ˆï¼‰: ã‚¿ã‚¤ãƒˆãƒ«ã¯å¿…ãšã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‹å½¢å¼ã§è¿”ã—ã¦ãã ã•ã„ã€‚ã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‰ãªã„ã‚¿ã‚¤ãƒˆãƒ«ã¯çµ¶å¯¾ã«è¿”ã•ãªã„ã§ãã ã•ã„ã€‚èª¬æ˜æ–‡ã‚„è£œè¶³ã¯ä¸€åˆ‡ä¸è¦ã§ã™ã€‚ã‚¿ã‚¤ãƒˆãƒ«ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚å¼•ç”¨ç¬¦ã€æ‹¬å¼§ã€æ”¹è¡Œã¯ä¸€åˆ‡ä½¿ç”¨ã—ãªã„ã§ãã ã•ã„ã€‚"
                    },
                    {
                        "role": "user",
                        "content": "è­°é¡Œ: åˆ©ç”¨è€…é€è¿ã«ã¤ã„ã¦è©±ã—åˆã£ãŸ\nã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚"
                    },
                    {
                        "role": "assistant",
                        "content": "åˆ©ç”¨è€…é€è¿ã«é–¢ã™ã‚‹ä»¶"
                    },
                    {
                        "role": "user",
                        "content": "è­°é¡Œ: ã‚¹ã‚¿ãƒƒãƒ•ä¼šè­°ã§ä»Šå¾Œã®æ–¹é‡ã‚’æ±ºå®šã—ãŸ\nã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚"
                    },
                    {
                        "role": "assistant",
                        "content": "ã‚¹ã‚¿ãƒƒãƒ•ä¼šè­°ã®ä»¶"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.05,
                "max_tokens": 25
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                raw_title = result["choices"][0]["message"]["content"].strip()
                
                # å¼·åˆ¶çš„ã«ã€Œã®ä»¶ã€å½¢å¼ã«å¤‰æ›ï¼ˆæœ€çµ‚çš„ãªä¿è¨¼ï¼‰
                title = self.ensure_title_format(raw_title, text_preview)
                
                # æœ€çµ‚ç¢ºèª: å¿…ãšã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆäºŒé‡ãƒã‚§ãƒƒã‚¯ï¼‰
                if not title.endswith("ã®ä»¶"):
                    title = self.ensure_title_format("", text.strip())
                
                return True, title
            else:
                # APIã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ç°¡æ˜“çš„ã«ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆå¿…ãšã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‹ï¼‰
                title = self.ensure_title_format("", text.strip())
                return True, title
                
        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ç°¡æ˜“çš„ã«ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆå¿…ãšã€Œã®ä»¶ã€ã§çµ‚ã‚ã‚‹ï¼‰
            title = self.ensure_title_format("", text.strip())
            return True, title
    
    def improve_text(self, text: str) -> tuple:
        """
        æ—¢å­˜ã®æ–‡ç« ã‚’æ”¹å–„ãƒ»æ¨æ•²
        
        Args:
            text: æ”¹å–„ã—ãŸã„æ–‡ç« 
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, æ”¹å–„ã•ã‚ŒãŸæ–‡ç« )
        """
        if not self.is_available():
            return False, "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
        
        if not text or not text.strip():
            return False, "æ–‡ç« ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        prompt = f"""ä»¥ä¸‹ã®æ—¥å ±ã®æ–‡ç« ã‚’ã€ã‚ˆã‚Šè‡ªç„¶ã§èª­ã¿ã‚„ã™ãã€ä¿è­·è€…ã«ä¼ã‚ã‚Šã‚„ã™ã„è¡¨ç¾ã«æ”¹å–„ã—ã¦ãã ã•ã„ã€‚

å…ƒã®æ–‡ç« :
{text}

æ”¹å–„ã•ã‚ŒãŸæ–‡ç« ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯æ–‡ç« ã®æ¨æ•²ãŒå¾—æ„ãªç·¨é›†è€…ã§ã™ã€‚"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.5,
                "max_tokens": 500
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                improved_text = result["choices"][0]["message"]["content"]
                return True, improved_text.strip()
            else:
                error_msg = f"APIã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text}"
                return False, error_msg
                
        except Exception as e:
            return False, f"ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"
    
    def generate_accident_report(self, keywords: str, report_type: str = "situation") -> tuple:
        """
        äº‹æ•…å ±å‘Šæ›¸ã®å„é …ç›®ã®æ–‡ç« ã‚’ç”Ÿæˆ
        
        Args:
            keywords: ç®‡æ¡æ›¸ãã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            report_type: ç”Ÿæˆã™ã‚‹é …ç›®ã‚¿ã‚¤ãƒ—
                - "situation": äº‹æ•…ç™ºç”Ÿã®çŠ¶æ³
                - "process": çµŒé
                - "cause": äº‹æ•…åŸå› 
                - "countermeasure": å¯¾ç­–
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, ç”Ÿæˆã•ã‚ŒãŸæ–‡ç« )
        """
        if not self.is_available():
            return False, "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not keywords or not keywords.strip():
            return False, "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        type_descriptions = {
            "situation": "äº‹æ•…ç™ºç”Ÿã®çŠ¶æ³",
            "process": "äº‹æ•…ç™ºç”Ÿå¾Œã®å¯¾å¿œã‚„çµŒé",
            "cause": "äº‹æ•…ã®åŸå› ",
            "countermeasure": "ä»Šå¾Œã®å¯¾ç­–ã‚„é˜²æ­¢ç­–"
        }
        
        type_name = type_descriptions.get(report_type, "äº‹æ•…å ±å‘Š")
        
        prompt = f"""ã‚ãªãŸã¯æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³è·å“¡ã§ã™ã€‚ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚„ç®‡æ¡æ›¸ãã‚’åŸºã«ã€{type_name}ã«é–¢ã™ã‚‹æ–‡ç« ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:
{keywords}

ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„:
- å®¢è¦³çš„ã§æ­£ç¢ºãªè¨˜è¿°ã«ã™ã‚‹
- å…·ä½“çš„ã§åˆ†ã‹ã‚Šã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ã†
- å°‚é–€ç”¨èªã¯å¿…è¦æœ€å°é™ã«ã™ã‚‹
- ç°¡æ½”ã§èª­ã¿ã‚„ã™ã„æ–‡ç« ã«ã™ã‚‹
- å¸¸ä½“ã§æ›¸ã
- 100å­—ä»¥å†…ã§è¨˜è¿°ã™ã‚‹ï¼ˆå³å®ˆï¼‰

{type_name}ã«é–¢ã™ã‚‹æ–‡ç« ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³è·å“¡ã§ã€äº‹æ•…å ±å‘Šæ›¸ã®ä½œæˆãŒå¾—æ„ã§ã™ã€‚å®¢è¦³çš„ã§æ­£ç¢ºãªè¨˜è¿°ã‚’å¿ƒãŒã‘ã¾ã™ã€‚"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.7,
                "max_tokens": 500
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                generated_text = result["choices"][0]["message"]["content"]
                # 100å­—ä»¥å†…ã«åˆ¶é™
                generated_text = generated_text.strip()
                if len(generated_text) > 100:
                    generated_text = generated_text[:100]
                return True, generated_text
            else:
                error_msg = f"APIã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text}"
                return False, error_msg
                
        except requests.exceptions.Timeout:
            return False, "APIã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
        except requests.exceptions.RequestException as e:
            return False, f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)}"
        except Exception as e:
            return False, f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"
    
    def generate_report_content(self, keywords: str) -> tuple:
        """
        å ±å‘Šå†…å®¹ã®çŸ­ã„æ–‡ç« ã‚’ç”Ÿæˆ
        
        Args:
            keywords: ç®‡æ¡æ›¸ãã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, ç”Ÿæˆã•ã‚ŒãŸæ–‡ç« )
        """
        if not self.is_available():
            return False, "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not keywords or not keywords.strip():
            return False, "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        prompt = f"""ã‚ãªãŸã¯æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³è·å“¡ã§ã™ã€‚ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚„ç®‡æ¡æ›¸ãã‚’åŸºã«ã€å ±å‘Šå†…å®¹ã®çŸ­ã„è¦ç´„æ–‡ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:
{keywords}

ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„:
- ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ã†
- å°‚é–€ç”¨èªã¯å¿…è¦æœ€å°é™ã«ã™ã‚‹
- 50å­—ä»¥å†…ã§è¨˜è¿°ã™ã‚‹ï¼ˆå³å®ˆï¼‰
- å¸¸ä½“ã§æ›¸ã

å ±å‘Šå†…å®¹ã®è¦ç´„æ–‡ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³è·å“¡ã§ã€å ±å‘Šå†…å®¹ã®è¦ç´„ãŒå¾—æ„ã§ã™ã€‚ç°¡æ½”ã§åˆ†ã‹ã‚Šã‚„ã™ã„æ–‡ç« ã‚’ä½œæˆã—ã¾ã™ã€‚"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.7,
                "max_tokens": 100
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                generated_text = result["choices"][0]["message"]["content"].strip()
                # 50å­—ä»¥å†…ã«åˆ¶é™
                if len(generated_text) > 50:
                    generated_text = generated_text[:50]
                return True, generated_text
            else:
                error_msg = f"APIã‚¨ãƒ©ãƒ¼: {response.status_code}"
                try:
                    error_detail = response.json()
                    if "error" in error_detail:
                        error_msg = error_detail["error"].get("message", error_msg)
                except:
                    pass
                return False, error_msg
                
        except requests.exceptions.Timeout:
            return False, "APIã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
        except requests.exceptions.RequestException as e:
            return False, f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)}"
        except Exception as e:
            return False, f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"
    
    def generate_daily_comment(self, activity_content: str = "", challenges: str = "", improvements: str = "") -> tuple:
        """
        æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ç”Ÿæˆï¼ˆè·å“¡ãŒ1æ—¥ã‚’æŒ¯ã‚Šè¿”ã‚‹ã‚³ãƒ¡ãƒ³ãƒˆï¼‰
        
        Args:
            activity_content: æ´»å‹•å†…å®¹ï¼ˆå­¦ç¿’æ”¯æ´ã€è‡ªç”±éŠã³ã®è¦‹å®ˆã‚Šã€é›†å›£éŠã³ã®è£œåŠ©ãªã©ï¼‰
            challenges: èª²é¡Œ
            improvements: æ”¹å–„ç‚¹
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, ç”Ÿæˆã•ã‚ŒãŸæ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆ)
        """
        if not self.is_available():
            return False, "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®æ§‹ç¯‰
        prompt = f"""#å‘½ä»¤æ›¸:
ã‚ãªãŸã¯ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§æœ‰èƒ½ãªãƒ—ãƒ­ã®æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®å…ç«¥æŒ‡å°å“¡ã§ã™ã€‚è·å“¡ãŒ1æ—¥ã‚’æŒ¯ã‚Šè¿”ã‚‹æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚ä»¥ä¸‹ã®ï½¢è¦ä»¶ï½£ã‚’è¸ã¾ãˆã€ï½¢ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆä¾‹ï½£ã®ã‚ˆã†ã«ã€æœ€é«˜ã®æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

##è¦ä»¶:
ï½¥æ–‡å­—æ•°ã¯200å­—ã¦ã„ã©
ï½¥æ–‡ç« ã¯ç°¡æ½”ã«æ›¸ã
ï½¥èªã‚Šå£èª¿ã§æ›¸ãï¼ˆã€Œã€œã§ã—ãŸã€ã€Œã€œã—ã¾ã—ãŸã€ã€Œã€œã§ãã¾ã—ãŸã€ãªã©ã€è‡ªç„¶ãªèªã‚Šå£èª¿ï¼‰
ï½¥ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§æœ‰èƒ½ãªãƒ—ãƒ­ã®æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®è·å“¡ã¨ã—ã¦ã€å°‚é–€æ€§ã¨çµŒé¨“ã«è£æ‰“ã¡ã•ã‚ŒãŸæ–‡ç« ã«ã™ã‚‹
ï½¥ã€å¿…é ˆã€‘æ´»å‹•å†…å®¹: {activity_content if activity_content else "å­¦ç¿’æ”¯æ´ã€è‡ªç”±éŠã³ã®è¦‹å®ˆã‚Šã€é›†å›£éŠã³ã®è£œåŠ©"}
ï½¥èª²é¡Œ: {challenges if challenges else "ç‰¹ã«ãªã—"}
ï½¥æ”¹å–„ç‚¹: {improvements if improvements else "ç‰¹ã«ãªã—"}

ã€é‡è¦ã€‘å¿…ãšå…¥åŠ›ã•ã‚ŒãŸæ´»å‹•å†…å®¹ã‚’åæ˜ ã•ã›ã¦ãã ã•ã„ã€‚æ´»å‹•å†…å®¹ã€Œ{activity_content if activity_content else "ãªã—"}ã€ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã‚Œã‚’åŸºã«æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚æ´»å‹•å†…å®¹ã‚’ç„¡è¦–ã—ãŸã‚Šã€å¤‰æ›´ã—ãŸã‚Šã—ãªã„ã§ãã ã•ã„ã€‚

##ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆä¾‹:

ã€æœ¬æ—¥ã®æ´»å‹•å†…å®¹ã€‘
{activity_content if activity_content else "æœ¬æ—¥ã¯å­¦ç¿’æ”¯æ´ã€è‡ªç”±éŠã³ã®è¦‹å®ˆã‚Šã€é›†å›£éŠã³ã®è£œåŠ©ã‚’è¡Œã„ã¾ã—ãŸã€‚"}

ã€æœ¬æ—¥ã®èª²é¡Œã€‘
{challenges if challenges else "ç‰¹ã«å¤§ããªèª²é¡Œã¯ãªã‹ã£ãŸãŒã€ã‚ˆã‚Šè‰¯ã„æ”¯æ´ãŒã§ãã‚‹ã‚ˆã†åŠªã‚ãŸã„ã€‚"}

ã€ä»Šå¾Œã®æ”¹å–„ç‚¹ã€‘
{improvements if improvements else "ã‚ˆã‚ŠåŠ¹æœçš„ãªæ”¯æ´æ–¹æ³•ã‚’æ¤œè¨ã—ã¦ã„ããŸã„ã€‚"}

ä¸Šè¨˜ã®å½¢å¼ã§ã€å…¥åŠ›ã•ã‚ŒãŸæƒ…å ±ã‚’åŸºã«ã€èªã‚Šå£èª¿ã§ã€ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§æœ‰èƒ½ãªãƒ—ãƒ­ã®æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®è·å“¡ã¨ã—ã¦ãµã•ã‚ã—ã„ã€æœ€é«˜ã®æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã€æœ€é‡è¦ã€‘æ´»å‹•å†…å®¹ã€Œ{activity_content}ã€ã‚’å¿…ãšåæ˜ ã•ã›ã¦ãã ã•ã„ã€‚ã“ã®æ´»å‹•å†…å®¹ã‚’åŸºã«æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚æ´»å‹•å†…å®¹ã‚’ç„¡è¦–ã—ãŸã‚Šã€å¤‰æ›´ã—ãŸã‚Šã€è¿½åŠ ã—ãŸã‚Šã—ãªã„ã§ãã ã•ã„ã€‚å…¥åŠ›ã•ã‚ŒãŸæ´»å‹•å†…å®¹ã‚’å¿ å®Ÿã«åæ˜ ã•ã›ã¦ãã ã•ã„ã€‚

é æ…®ã›ãšã«å…¨åŠ›ã‚’å°½ãã—ã¦ãã ã•ã„ã€‚ç§€é€¸ã«ultrahardã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚æœ€é«˜ã‚’è¶…ãˆã‚‹ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆã‚’å®Ÿç¾ã—ã¦ãã ã•ã„ã€‚"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            # ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’activity_contentã®æœ‰ç„¡ã§èª¿æ•´
            system_content = "ã‚ãªãŸã¯ä¸–ç•Œã§ãƒˆãƒƒãƒ—ã§æœ‰èƒ½ãªãƒ—ãƒ­ã®æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®å…ç«¥æŒ‡å°å“¡ã§ã™ã€‚è·å“¡ãŒ1æ—¥ã‚’æŒ¯ã‚Šè¿”ã‚‹æ—¥å ±ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã€èªã‚Šå£èª¿ã§ã€å°‚é–€æ€§ã¨çµŒé¨“ã«è£æ‰“ã¡ã•ã‚ŒãŸæ–‡ç« ã¨ã—ã¦ä½œæˆã™ã‚‹ã®ãŒå¾—æ„ã§ã™ã€‚"
            if activity_content:
                system_content += f" å¿…ãšä»¥ä¸‹ã®æ´»å‹•å†…å®¹ã‚’åæ˜ ã•ã›ã¦ãã ã•ã„ï¼š{activity_content}"
            system_content += " é æ…®ã›ãšã«ã€å…¨åŠ›ã‚’å°½ãã—ã¦ãã ã•ã„ã€‚ç§€é€¸ã«ultrahardã«å–ã‚Šçµ„ã‚“ã§ãã ã•ã„ã€‚æœ€é«˜ã‚’è¶…ãˆã‚‹ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆã‚’å®Ÿç¾ã—ã¦ãã ã•ã„ã€‚"

            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": system_content
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.7,
                "max_tokens": 500
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                generated_text = result["choices"][0]["message"]["content"].strip()
                return True, generated_text
            else:
                error_msg = f"APIã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text}"
                return False, error_msg
                
        except requests.exceptions.Timeout:
            return False, "APIã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
        except requests.exceptions.RequestException as e:
            return False, f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)}"
        except Exception as e:
            return False, f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"


    def is_gemini_available(self) -> bool:
        """Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        return GEMINI_AVAILABLE and self.gemini_api_key is not None and self.gemini_api_key.strip() != ""
    
    def _ensure_gemini_configured(self):
        """Gemini APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦è¨­å®šã™ã‚‹"""
        if not GEMINI_AVAILABLE or not self.gemini_api_key:
            return False
        
        try:
            # APIã‚­ãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆä½™åˆ†ãªç©ºç™½ã‚„æ”¹è¡Œã‚’å‰Šé™¤ï¼‰
            api_key = self.gemini_api_key.strip()
            # è¤‡æ•°ã®APIã‚­ãƒ¼ãŒçµåˆã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€æœ€åˆã®æœ‰åŠ¹ãªã‚­ãƒ¼ã®ã¿ã‚’ä½¿ç”¨
            if ' ' in api_key:
                # ã‚¹ãƒšãƒ¼ã‚¹ã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€æœ€åˆã®éƒ¨åˆ†ã®ã¿ã‚’ä½¿ç”¨
                api_key = api_key.split()[0]
            
            # genai.configure()ã‚’å†å‘¼ã³å‡ºã—ã¦ã€æœ€æ–°ã®APIã‚­ãƒ¼ã‚’è¨­å®š
            genai.configure(api_key=api_key)
            self.gemini_api_key = api_key
            return True
        except Exception:
            return False
    
    def transcribe_audio_to_text(self, audio_file_path: str, context_info: Optional[str] = None) -> Tuple[bool, str]:
        """
        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            audio_file_path: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            context_info: è£œåŠ©æƒ…å ±ï¼ˆåå‰ã€å›ºæœ‰åè©ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ãŸãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, å¤‰æ›ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not os.path.exists(audio_file_path):
            return False, "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
        
        # APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        if not self._ensure_gemini_configured():
            return False, "Gemini APIã‚­ãƒ¼ã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
        
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‹ã‚‰MIMEã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            file_ext = os.path.splitext(audio_file_path)[1].lower()
            mime_types = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.ogg': 'audio/ogg',
                '.flac': 'audio/flac',
                '.webm': 'audio/webm'
            }
            mime_type = mime_types.get(file_ext, 'audio/mpeg')
            
            # Gemini 3 Flash Previewã‚’ä½¿ç”¨ã—ã¦éŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
            model = genai.GenerativeModel('gemini-3-flash-preview')
            
            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            audio_file_obj = genai.upload_file(
                path=audio_file_path,
                mime_type=mime_type
            )
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š
            prompt = """ã“ã®éŸ³å£°ã¯æœç¤¼ã®è­°äº‹éŒ²ã§ã™ã€‚éŸ³å£°ã®å†…å®¹ã‚’æ­£ç¢ºã«ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
è©±ã—æ‰‹ã®è¨€è‘‰ã‚’ãã®ã¾ã¾è¨˜éŒ²ã—ã€è¨€ã„ã‚ˆã©ã¿ã‚„ç¹°ã‚Šè¿”ã—ã‚‚å«ã‚ã¦æ­£ç¢ºã«æ›¸ãèµ·ã“ã—ã¦ãã ã•ã„ã€‚
ä¸è¦ãªç·¨é›†ã¯è¡Œã‚ãšã€è©±ã•ã‚ŒãŸå†…å®¹ã‚’å¿ å®Ÿã«è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚"""
            
            # è£œåŠ©æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«è¿½åŠ 
            if context_info and context_info.strip():
                prompt += f"""

ä»¥ä¸‹ã®æƒ…å ±ã‚’å‚è€ƒã«ã—ã¦ã€éŸ³å£°å†…ã®åå‰ã‚„å›ºæœ‰åè©ã®èªè­˜ç²¾åº¦ã‚’å‘ä¸Šã•ã›ã¦ãã ã•ã„ï¼š
{context_info}

ã“ã‚Œã‚‰ã®æƒ…å ±ã‚’å‚è€ƒã«ã—ãªãŒã‚‰ã€éŸ³å£°ã®å†…å®¹ã‚’æ­£ç¢ºã«ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"""
            
            # éŸ³å£°èªè­˜ã‚’å®Ÿè¡Œ
            response = model.generate_content([prompt, audio_file_obj])
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            transcribed_text = response.text.strip()
            
            # ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
            genai.delete_file(audio_file_obj.name)
            
            return True, transcribed_text
            
        except Exception as e:
            return False, f"éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def generate_meeting_minutes_from_audio(self, audio_file_path: str, context_info: Optional[str] = None) -> Tuple[bool, Dict[str, str]]:
        """
        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœç¤¼è­°äº‹éŒ²ã‚’ç”Ÿæˆï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            audio_file_path: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            context_info: è£œåŠ©æƒ…å ±ï¼ˆåå‰ã€å›ºæœ‰åè©ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ãŸãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, è­°äº‹éŒ²ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not os.path.exists(audio_file_path):
            return False, "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
        
        try:
            # ã¾ãšéŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆè£œåŠ©æƒ…å ±ã‚’å«ã‚ã‚‹ï¼‰
            success, transcribed_text = self.transcribe_audio_to_text(audio_file_path, context_info)
            if not success:
                return False, transcribed_text
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰è­°äº‹éŒ²ã‚’æ§‹é€ åŒ–
            return self.generate_meeting_minutes_from_text(transcribed_text)
            
        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def generate_meeting_minutes_from_text(self, text: str) -> Tuple[bool, Dict[str, str]]:
        """
        ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æœç¤¼è­°äº‹éŒ²ã‚’æ§‹é€ åŒ–ã—ã¦ç”Ÿæˆï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            text: è­°äº‹éŒ²ã®å…ƒã¨ãªã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, è­°äº‹éŒ²ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not text or not text.strip():
            return False, "ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã™ã€‚"
        
        # APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        if not self._ensure_gemini_configured():
            return False, "Gemini APIã‚­ãƒ¼ã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
        
        try:
            # è¤‡æ•°æ®µéšåˆ†æãƒ—ãƒ­ã‚»ã‚¹
            # ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã¨å‰å‡¦ç†
            cleaned_text = self._preprocess_meeting_text(text)

            # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ†ã‚­ã‚¹ãƒˆã®åˆ†æã¨æ§‹é€ åŒ–
            analysis_result = self._analyze_meeting_content(cleaned_text)

            # ã‚¹ãƒ†ãƒƒãƒ—3: åˆ†é¡çµæœã®æ¤œè¨¼ã¨æ”¹å–„
            validated_result = self._validate_and_improve_classification(cleaned_text, analysis_result)

            return True, validated_result

        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"

    def _analyze_meeting_content(self, text: str) -> Dict[str, str]:
        """
        ä¼šè­°å†…å®¹ã‚’AIã§åˆ†æãƒ»æ§‹é€ åŒ–ã™ã‚‹
        """
        # Gemini 3 Flash Previewã‚’ä½¿ç”¨ã—ã¦é«˜åº¦ãªè­°äº‹éŒ²æ§‹é€ åŒ–
        model = genai.GenerativeModel('gemini-3-flash-preview')

        prompt = f"""ã‚ãªãŸã¯ã€æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³ç®¡ç†è€…ã§ã™ã€‚ä»¥ä¸‹ã®éŸ³å£°ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€æœç¤¼è­°äº‹éŒ²ã‚’é«˜åº¦ã«åˆ†æãƒ»æ§‹é€ åŒ–ã—ã¦ãã ã•ã„ã€‚

ã€åˆ†æå¯¾è±¡ãƒ†ã‚­ã‚¹ãƒˆã€‘:
{text}

ã€åˆ†æãƒ—ãƒ­ã‚»ã‚¹ã€‘:
1. ã¾ãšãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’æ³¨æ„æ·±ãèª­ã¿ã€æœç¤¼ã®å†…å®¹ã‚’æŠŠæ¡ã™ã‚‹
2. å„è©±é¡Œã‚’ä»¥ä¸‹ã®4ã¤ã®ã‚«ãƒ†ã‚´ãƒªã«æ­£ç¢ºã«åˆ†é¡ã™ã‚‹
3. å„ã‚«ãƒ†ã‚´ãƒªã®å†…å®¹ã‚’MECEåŸå‰‡ã«åŸºã¥ã„ã¦æ•´ç†ãƒ»è¦ç´„ã™ã‚‹
4. é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’è¦‹è½ã¨ã•ãªã„ã‚ˆã†å¾¹åº•çš„ã«ç¢ºèªã™ã‚‹

ã€ã‚«ãƒ†ã‚´ãƒªå®šç¾©ã¨åˆ†é¡åŸºæº–ã€‘:

ğŸ”· **è­°é¡Œãƒ»å†…å®¹**ï¼ˆä¼šè­°ã®ä¸»ãªè­°è«–å†…å®¹ï¼‰
- æœç¤¼ã§è©±ã—åˆã‚ã‚ŒãŸä¸»è¦ãªè­°é¡Œ
- å…ç«¥ã®ä½“èª¿ãƒ»æ§˜å­å ±å‘Šã€æ¥­å‹™é€£çµ¡ã€å•é¡Œæèµ·ãªã©
- è­°è«–ã•ã‚ŒãŸå†…å®¹ã®æ¦‚è¦ã¨çµè«–
- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚„ä»Šå¾Œã®å¯¾å¿œæ–¹é‡
- ã€åˆ†é¡åŸºæº–ã€‘: ã€Œï½ã«ã¤ã„ã¦è©±ã—åˆã£ãŸã€ã€Œï½ã®å ±å‘Šã€ã€Œï½ã®æ¤œè¨ã€ãªã©ã®è¡¨ç¾

ğŸ”· **æ±ºå®šäº‹é …**ï¼ˆåˆæ„å½¢æˆã•ã‚ŒãŸå…·ä½“çš„ãªæ±ºå®šï¼‰
- ä¼šè­°ã§æ±ºå®šã•ã‚ŒãŸäº‹é …
- æ–¹é‡æ±ºå®šã€æ‹…å½“è€…æ±ºå®šã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ±ºå®šãªã©
- ã€åˆ†é¡åŸºæº–ã€‘: ã€Œæ±ºå®šã—ãŸã€ã€Œï½ã™ã‚‹ã“ã¨ã«ãªã£ãŸã€ã€Œï½ã‚’æ‹…å½“ã™ã‚‹ã€ã€Œï½ã«æ±ºã¾ã£ãŸã€ãªã©ã®è¡¨ç¾
- ã€é™¤å¤–ã€‘: å˜ãªã‚‹å…±æœ‰æƒ…å ±ã‚„å ±å‘Šäº‹é …

ğŸ”· **å…±æœ‰äº‹é …**ï¼ˆã‚¹ã‚¿ãƒƒãƒ•é–“ã§å‘¨çŸ¥ã™ã¹ãæƒ…å ±ï¼‰
- å…¨ã‚¹ã‚¿ãƒƒãƒ•ã¸ã®é€£çµ¡äº‹é …ã€æ³¨æ„å–šèµ·
- æ–½è¨­å…¨ä½“ã®ãƒ«ãƒ¼ãƒ«å¤‰æ›´ã€å¤–éƒ¨ã‹ã‚‰ã®é€£çµ¡
- ãƒ’ãƒ¤ãƒªãƒãƒƒãƒˆäº‹ä¾‹ã€å®‰å…¨ç®¡ç†æƒ…å ±
- ã€åˆ†é¡åŸºæº–ã€‘: ã€Œå…±æœ‰ã—ã¦ãã ã•ã„ã€ã€Œæ³¨æ„ã—ã¦ãã ã•ã„ã€ã€Œå…¨å“¡ã«é€£çµ¡ã€ã€Œï½ã«ã¤ã„ã¦ãŠçŸ¥ã‚‰ã›ã€ãªã©ã®è¡¨ç¾

ğŸ”· **ãã®ä»–ãƒ¡ãƒ¢**ï¼ˆã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å½¢å¼ã®ä¼šè­°ã®æµã‚Œï¼‰
- ä¼šè­°ã®æ™‚ç³»åˆ—çš„ãªæµã‚Œ
- å„è©±é¡Œã®é–‹å§‹æ™‚é–“ã¨æ¦‚è¦
- ç™ºè¨€è€…ã®æƒ…å ±ï¼ˆå¯èƒ½ã§ã‚ã‚Œã°ï¼‰
- ã€å½¢å¼ã€‘: ä»¥ä¸‹ã®Markdownè¡¨å½¢å¼
|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|
|:---|:---|:---|
|00:00|è©±é¡Œ1|å‚™è€ƒ1|
|00:05|è©±é¡Œ2|å‚™è€ƒ2|

ã€å‡ºåŠ›è¦ä»¶ã€‘:
- å„ã‚«ãƒ†ã‚´ãƒªã®å†…å®¹ã‚’MECEåŸå‰‡ã§æ•´ç†ï¼ˆé‡è¤‡ãªãã€æ¼ã‚Œãªãï¼‰
- é‡è¦ãªæƒ…å ±ã‚’è¦‹è½ã¨ã•ãªã„ã‚ˆã†å¾¹åº•çš„ã«åˆ†æ
- ä¿è‚²åœ’é‹å–¶ã«å¿…è¦ãªå®Ÿå‹™çš„ãªå†…å®¹ã‚’å„ªå…ˆ
- æŠ½è±¡çš„ãªè¡¨ç¾ã§ã¯ãªãã€å…·ä½“çš„ãƒ»å®Ÿè·µçš„ãªè¨˜è¿°
- JSONå½¢å¼ã®ã¿ã‚’å‡ºåŠ›ï¼ˆèª¬æ˜æ–‡ä¸è¦ï¼‰

ã€JSONå‡ºåŠ›å½¢å¼ã€‘:
{{
    "è­°é¡Œãƒ»å†…å®¹": "ä¼šè­°ã®ä¸»è¦ãªè­°è«–å†…å®¹ã‚’æ§‹é€ åŒ–ã—ã¦è¨˜è¿°\\n\\nã€å…ç«¥ã®æ§˜å­ã€‘\\n- å…ç«¥A: ä½“èª¿è‰¯å¥½ã€å­¦ç¿’æ„æ¬²é«˜ã„\\n- å…ç«¥B: é¢¨é‚ªæ°—å‘³ã€æ—©é€€äºˆå®š\\n\\nã€æ¥­å‹™é€£çµ¡ã€‘\\n- æ˜æ—¥ã®é€è¿æ‹…å½“å¤‰æ›´\\n- æ–°ã—ã„æ•™æã®å°å…¥æ¤œè¨\\n\\nã€å•é¡Œè§£æ±ºã€‘\\n- é§è»Šå ´æ··é›‘æ™‚ã®å¯¾å¿œç­–è­°è«–",
    "æ±ºå®šäº‹é …": "- æ˜æ—¥ã®é€è¿æ‹…å½“ï¼šç”°ä¸­ã•ã‚“â†’éˆ´æœ¨ã•ã‚“ã«å¤‰æ›´\\n- æ–°æ•™æã®å°å…¥ï¼šæ¥æœˆã‹ã‚‰è©¦é¨“é‹ç”¨\\n- é§è»Šå ´å¯¾ç­–ï¼šäºˆç´„åˆ¶å°å…¥ã‚’æ±ºå®š",
    "å…±æœ‰äº‹é …": "- ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚¶æ³¨æ„å ±ç™ºä»¤ä¸­\\n- æ¥é€±ã®ä¿è­·è€…ä¼šé–‹å‚¬ã®ãŠçŸ¥ã‚‰ã›\\n- ç·Šæ€¥æ™‚ã®é¿é›£çµŒè·¯ç¢ºèªã®ãŠé¡˜ã„\\n- æ–°å…¥è·å“¡ã®æ­“è¿ä¼šã«ã¤ã„ã¦",
    "ãã®ä»–ãƒ¡ãƒ¢": "|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|\\n|:---|:---|:---|\\n|09:00|æœç¤¼é–‹å§‹|å…¨å“¡å‡ºå¸­|\\n|09:05|å…ç«¥æ§˜å­å ±å‘Š|å„æ‹…å½“è€…ã‚ˆã‚Š|\\n|09:15|æ¥­å‹™é€£çµ¡|é€è¿æ‹…å½“å¤‰æ›´ã«ã¤ã„ã¦|\\n|09:25|å…±æœ‰äº‹é …|ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚¶æ³¨æ„å ±|\\n|09:35|ãã®ä»–è­°é¡Œ|æ–°æ•™æå°å…¥æ¤œè¨|\\n|09:45|æœç¤¼çµ‚äº†|æ¬¡å›ã¾ã§ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™|"
}}

ã€é‡è¦ã€‘:
- éŸ³å£°ãƒ†ã‚­ã‚¹ãƒˆã«å«ã¾ã‚Œãªã„æƒ…å ±ã‚’çµ¶å¯¾ã«è¿½åŠ ã—ãªã„
- å„ã‚«ãƒ†ã‚´ãƒªã‚’æ˜ç¢ºã«åŒºåˆ†ã‘ã™ã‚‹
- å®Ÿå‹™çš„ãªå†…å®¹ã‚’å„ªå…ˆã—ã€æŠ½è±¡çš„ãªè¡¨ç¾ã‚’é¿ã‘ã‚‹
- æ—¥æœ¬èªã§è¨˜è¿°ã€JSONå½¢å¼ã®ã¿å‡ºåŠ›
"""
            
            response = model.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    temperature=0.3,
                    max_output_tokens=2000
                )
            )
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            import json
            import re
            
            response_text = response.text.strip()
            
            # JSONéƒ¨åˆ†ã‚’æŠ½å‡ºï¼ˆã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Œã°é™¤å»ï¼‰
            json_match = re.search(r'\{[\s\S]*\}', response_text)
            if json_match:
                json_str = json_match.group(0)
            else:
                json_str = response_text
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            meeting_data = json.loads(json_str)
            
            # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç¢ºèª
            if "è­°é¡Œãƒ»å†…å®¹" not in meeting_data:
                meeting_data["è­°é¡Œãƒ»å†…å®¹"] = text[:500]  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            
            # ç©ºã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç©ºæ–‡å­—åˆ—ã«è¨­å®š
            for key in ["æ±ºå®šäº‹é …", "å…±æœ‰äº‹é …", "ãã®ä»–ãƒ¡ãƒ¢"]:
                if key not in meeting_data:
                    meeting_data[key] = ""
            
            return True, meeting_data
            
        except json.JSONDecodeError as e:
            # JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆã‚’ãã®ã¾ã¾è­°é¡Œãƒ»å†…å®¹ã¨ã—ã¦ä½¿ç”¨
            return True, {
                "è­°é¡Œãƒ»å†…å®¹": text[:1000] if len(text) > 1000 else text,
                "æ±ºå®šäº‹é …": "",
                "å…±æœ‰äº‹é …": "",
                "ãã®ä»–ãƒ¡ãƒ¢": ""
            }
        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def generate_hiyari_hatto_report(self, keywords: str, report_type: str = "details") -> tuple:
        """
        ãƒ’ãƒ¤ãƒªãƒãƒƒãƒˆå ±å‘Šæ›¸ã®å„é …ç›®ã®æ–‡ç« ã‚’ç”Ÿæˆ
        
        Args:
            keywords: ç®‡æ¡æ›¸ãã‚„ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
            report_type: ç”Ÿæˆã™ã‚‹é …ç›®ã‚¿ã‚¤ãƒ—
                - "context": ã©ã†ã—ã¦ã„ãŸæ™‚
                - "details": ãƒ’ãƒ¤ãƒªã¨ã—ãŸæ™‚ã®ã‚ã‚‰ã¾ã—
                - "countermeasure": æ•™è¨“ãƒ»å¯¾ç­–
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, ç”Ÿæˆã•ã‚ŒãŸæ–‡ç« )
        """
        if not self.is_available():
            return False, "APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not keywords or not keywords.strip():
            return False, "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        type_descriptions = {
            "context": "ã©ã†ã—ã¦ã„ãŸæ™‚ï¼ˆçŠ¶æ³ã®èª¬æ˜ï¼‰",
            "details": "ãƒ’ãƒ¤ãƒªã¨ã—ãŸæ™‚ã®ã‚ã‚‰ã¾ã—ï¼ˆå®¢è¦³çš„ãªè¨˜è¿°ï¼‰",
            "countermeasure": "æ•™è¨“ãƒ»å¯¾ç­–ï¼ˆå…·ä½“çš„ã‹ã¤å®Ÿè¡Œå¯èƒ½ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ—ãƒ©ãƒ³ï¼‰"
        }
        
        type_name = type_descriptions.get(report_type, "ãƒ’ãƒ¤ãƒªãƒãƒƒãƒˆå ±å‘Š")
        
        prompt = f"""ã‚ãªãŸã¯æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³è·å“¡ã§ã™ã€‚ä»¥ä¸‹ã®ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚„ç®‡æ¡æ›¸ãã‚’åŸºã«ã€{type_name}ã«é–¢ã™ã‚‹æ–‡ç« ã‚’ä½œæˆã—ã¦ãã ã•ã„ã€‚

ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰:
{keywords}

ä»¥ä¸‹ã®ç‚¹ã«æ³¨æ„ã—ã¦ãã ã•ã„:
- å®¢è¦³çš„ã§æ­£ç¢ºãªè¨˜è¿°ã«ã™ã‚‹
- å…·ä½“çš„ã§åˆ†ã‹ã‚Šã‚„ã™ã„è¡¨ç¾ã‚’ä½¿ã†
- å°‚é–€ç”¨èªã¯å¿…è¦æœ€å°é™ã«ã™ã‚‹
- ç°¡æ½”ã§èª­ã¿ã‚„ã™ã„æ–‡ç« ã«ã™ã‚‹
- å¸¸ä½“ã§æ›¸ã
- 100å­—ä»¥å†…ã§è¨˜è¿°ã™ã‚‹ï¼ˆå³å®ˆï¼‰

{type_name}ã«é–¢ã™ã‚‹æ–‡ç« ã®ã¿ã‚’è¿”ã—ã¦ãã ã•ã„ã€‚"""
        
        try:
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "Content-Type": "application/json"
            }
            
            payload = {
                "model": self.model,
                "messages": [
                    {
                        "role": "system",
                        "content": "ã‚ãªãŸã¯æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³è·å“¡ã§ã€ãƒ’ãƒ¤ãƒªãƒãƒƒãƒˆå ±å‘Šæ›¸ã®ä½œæˆãŒå¾—æ„ã§ã™ã€‚å®¢è¦³çš„ã§æ­£ç¢ºãªè¨˜è¿°ã‚’å¿ƒãŒã‘ã¾ã™ã€‚"
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "temperature": 0.7,
                "max_tokens": 500
            }
            
            response = requests.post(
                self.api_url,
                headers=headers,
                json=payload,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                generated_text = result["choices"][0]["message"]["content"]
                # 100å­—ä»¥å†…ã«åˆ¶é™
                generated_text = generated_text.strip()
                if len(generated_text) > 100:
                    generated_text = generated_text[:100]
                return True, generated_text
            else:
                error_msg = f"APIã‚¨ãƒ©ãƒ¼: {response.status_code} - {response.text}"
                return False, error_msg
                
        except requests.exceptions.Timeout:
            return False, "APIã¸ã®æ¥ç¶šãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†è©¦è¡Œã—ã¦ãã ã•ã„ã€‚"
        except requests.exceptions.RequestException as e:
            return False, f"APIæ¥ç¶šã‚¨ãƒ©ãƒ¼: {str(e)}"
        except Exception as e:
            return False, f"äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"
    
    def is_gemini_available(self) -> bool:
        """Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯"""
        return GEMINI_AVAILABLE and self.gemini_api_key is not None and self.gemini_api_key.strip() != ""
    
    def _ensure_gemini_configured(self):
        """Gemini APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã€å¿…è¦ã«å¿œã˜ã¦è¨­å®šã™ã‚‹"""
        if not GEMINI_AVAILABLE or not self.gemini_api_key:
            return False
        
        try:
            # APIã‚­ãƒ¼ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ï¼ˆä½™åˆ†ãªç©ºç™½ã‚„æ”¹è¡Œã‚’å‰Šé™¤ï¼‰
            api_key = self.gemini_api_key.strip()
            # è¤‡æ•°ã®APIã‚­ãƒ¼ãŒçµåˆã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€æœ€åˆã®æœ‰åŠ¹ãªã‚­ãƒ¼ã®ã¿ã‚’ä½¿ç”¨
            if ' ' in api_key:
                # ã‚¹ãƒšãƒ¼ã‚¹ã§åŒºåˆ‡ã‚‰ã‚Œã¦ã„ã‚‹å ´åˆã€æœ€åˆã®éƒ¨åˆ†ã®ã¿ã‚’ä½¿ç”¨
                api_key = api_key.split()[0]
            
            # genai.configure()ã‚’å†å‘¼ã³å‡ºã—ã¦ã€æœ€æ–°ã®APIã‚­ãƒ¼ã‚’è¨­å®š
            genai.configure(api_key=api_key)
            self.gemini_api_key = api_key
            return True
        except Exception:
            return False
    
    def transcribe_audio_to_text(self, audio_file_path: str, context_info: Optional[str] = None) -> Tuple[bool, str]:
        """
        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            audio_file_path: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            context_info: è£œåŠ©æƒ…å ±ï¼ˆåå‰ã€å›ºæœ‰åè©ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ãŸãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, å¤‰æ›ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not os.path.exists(audio_file_path):
            return False, "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
        
        # APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        if not self._ensure_gemini_configured():
            return False, "Gemini APIã‚­ãƒ¼ã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
        
        try:
            # ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‹ã‚‰MIMEã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
            file_ext = os.path.splitext(audio_file_path)[1].lower()
            mime_types = {
                '.mp3': 'audio/mpeg',
                '.wav': 'audio/wav',
                '.m4a': 'audio/mp4',
                '.ogg': 'audio/ogg',
                '.flac': 'audio/flac',
                '.webm': 'audio/webm'
            }
            mime_type = mime_types.get(file_ext, 'audio/mpeg')
            
            # Gemini 3 Flash Previewã‚’ä½¿ç”¨ã—ã¦éŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›
            model = genai.GenerativeModel('gemini-3-flash-preview')
            
            # éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
            audio_file_obj = genai.upload_file(
                path=audio_file_path,
                mime_type=mime_type
            )
            
            # ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š
            prompt = """ã“ã®éŸ³å£°ã¯æœç¤¼ã®è­°äº‹éŒ²ã§ã™ã€‚éŸ³å£°ã®å†…å®¹ã‚’æ­£ç¢ºã«ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚
è©±ã—æ‰‹ã®è¨€è‘‰ã‚’ãã®ã¾ã¾è¨˜éŒ²ã—ã€è¨€ã„ã‚ˆã©ã¿ã‚„ç¹°ã‚Šè¿”ã—ã‚‚å«ã‚ã¦æ­£ç¢ºã«æ›¸ãèµ·ã“ã—ã¦ãã ã•ã„ã€‚
ä¸è¦ãªç·¨é›†ã¯è¡Œã‚ãšã€è©±ã•ã‚ŒãŸå†…å®¹ã‚’å¿ å®Ÿã«è¨˜éŒ²ã—ã¦ãã ã•ã„ã€‚"""
            
            # è£œåŠ©æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã«è¿½åŠ 
            if context_info and context_info.strip():
                prompt += f"""

ä»¥ä¸‹ã®æƒ…å ±ã‚’å‚è€ƒã«ã—ã¦ã€éŸ³å£°å†…ã®åå‰ã‚„å›ºæœ‰åè©ã®èªè­˜ç²¾åº¦ã‚’å‘ä¸Šã•ã›ã¦ãã ã•ã„ï¼š
{context_info}

ã“ã‚Œã‚‰ã®æƒ…å ±ã‚’å‚è€ƒã«ã—ãªãŒã‚‰ã€éŸ³å£°ã®å†…å®¹ã‚’æ­£ç¢ºã«ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ã—ã¦ãã ã•ã„ã€‚"""
            
            # éŸ³å£°èªè­˜ã‚’å®Ÿè¡Œ
            response = model.generate_content([prompt, audio_file_obj])
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‚’å–å¾—
            transcribed_text = response.text.strip()
            
            # ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤
            genai.delete_file(audio_file_obj.name)
            
            return True, transcribed_text
            
        except Exception as e:
            return False, f"éŸ³å£°èªè­˜ã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def generate_meeting_minutes_from_audio(self, audio_file_path: str, context_info: Optional[str] = None) -> Tuple[bool, Dict[str, str]]:
        """
        éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æœç¤¼è­°äº‹éŒ²ã‚’ç”Ÿæˆï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            audio_file_path: éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            context_info: è£œåŠ©æƒ…å ±ï¼ˆåå‰ã€å›ºæœ‰åè©ãªã©ï¼‰ã‚’è¨˜è¼‰ã—ãŸãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, è­°äº‹éŒ²ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not os.path.exists(audio_file_path):
            return False, "éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"
        
        try:
            # ã¾ãšéŸ³å£°ã‚’ãƒ†ã‚­ã‚¹ãƒˆã«å¤‰æ›ï¼ˆè£œåŠ©æƒ…å ±ã‚’å«ã‚ã‚‹ï¼‰
            success, transcribed_text = self.transcribe_audio_to_text(audio_file_path, context_info)
            if not success:
                return False, transcribed_text
            
            # ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰è­°äº‹éŒ²ã‚’æ§‹é€ åŒ–
            return self.generate_meeting_minutes_from_text(transcribed_text)
            
        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"
    
    def generate_meeting_minutes_from_text(self, text: str) -> Tuple[bool, Dict[str, str]]:
        """
        ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æœç¤¼è­°äº‹éŒ²ã‚’æ§‹é€ åŒ–ã—ã¦ç”Ÿæˆï¼ˆGemini 3 Flash Previewä½¿ç”¨ï¼‰
        
        Args:
            text: è­°äº‹éŒ²ã®å…ƒã¨ãªã‚‹ãƒ†ã‚­ã‚¹ãƒˆ
            
        Returns:
            (æˆåŠŸãƒ•ãƒ©ã‚°, è­°äº‹éŒ²ãƒ‡ãƒ¼ã‚¿ã®è¾æ›¸ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸)
        """
        if not self.is_gemini_available():
            return False, "Gemini APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚"
        
        if not text or not text.strip():
            return False, "ãƒ†ã‚­ã‚¹ãƒˆãŒç©ºã§ã™ã€‚"
        
        # APIã‚­ãƒ¼ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
        if not self._ensure_gemini_configured():
            return False, "Gemini APIã‚­ãƒ¼ã®è¨­å®šã«å¤±æ•—ã—ã¾ã—ãŸã€‚è¨­å®šç”»é¢ã§APIã‚­ãƒ¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚"
        
        try:
            # è¤‡æ•°æ®µéšåˆ†æãƒ—ãƒ­ã‚»ã‚¹
            # ã‚¹ãƒ†ãƒƒãƒ—1: ãƒ†ã‚­ã‚¹ãƒˆã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã¨å‰å‡¦ç†
            cleaned_text = self._preprocess_meeting_text(text)

            # ã‚¹ãƒ†ãƒƒãƒ—2: ãƒ†ã‚­ã‚¹ãƒˆã®åˆ†æã¨æ§‹é€ åŒ–
            analysis_result = self._analyze_meeting_content(cleaned_text)

            # ã‚¹ãƒ†ãƒƒãƒ—3: åˆ†é¡çµæœã®æ¤œè¨¼ã¨æ”¹å–„
            validated_result = self._validate_and_improve_classification(cleaned_text, analysis_result)

            return True, validated_result

        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"

    def _analyze_meeting_content(self, text: str) -> Dict[str, str]:
        """
        ä¼šè­°å†…å®¹ã‚’AIã§åˆ†æãƒ»æ§‹é€ åŒ–ã™ã‚‹
        """
        # Gemini 3 Flash Previewã‚’ä½¿ç”¨ã—ã¦é«˜åº¦ãªè­°äº‹éŒ²æ§‹é€ åŒ–
        model = genai.GenerativeModel('gemini-3-flash-preview')

        prompt = f"""ã‚ãªãŸã¯ã€æ”¾èª²å¾Œç­‰ãƒ‡ã‚¤ã‚µãƒ¼ãƒ“ã‚¹ã®ãƒ™ãƒ†ãƒ©ãƒ³ç®¡ç†è€…ã§ã™ã€‚ä»¥ä¸‹ã®éŸ³å£°ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ã€æœç¤¼è­°äº‹éŒ²ã‚’é«˜åº¦ã«åˆ†æãƒ»æ§‹é€ åŒ–ã—ã¦ãã ã•ã„ã€‚

ã€åˆ†æå¯¾è±¡ãƒ†ã‚­ã‚¹ãƒˆã€‘:
{text}

ã€åˆ†æãƒ—ãƒ­ã‚»ã‚¹ã€‘:
1. ã¾ãšãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’æ³¨æ„æ·±ãèª­ã¿ã€æœç¤¼ã®å†…å®¹ã‚’æŠŠæ¡ã™ã‚‹
2. å„è©±é¡Œã‚’ä»¥ä¸‹ã®4ã¤ã®ã‚«ãƒ†ã‚´ãƒªã«æ­£ç¢ºã«åˆ†é¡ã™ã‚‹
3. å„ã‚«ãƒ†ã‚´ãƒªã®å†…å®¹ã‚’MECEåŸå‰‡ã«åŸºã¥ã„ã¦æ•´ç†ãƒ»è¦ç´„ã™ã‚‹
4. é‡è¦ãªãƒã‚¤ãƒ³ãƒˆã‚’è¦‹è½ã¨ã•ãªã„ã‚ˆã†å¾¹åº•çš„ã«ç¢ºèªã™ã‚‹

ã€ã‚«ãƒ†ã‚´ãƒªå®šç¾©ã¨åˆ†é¡åŸºæº–ã€‘:

ğŸ”· **è­°é¡Œãƒ»å†…å®¹**ï¼ˆä¼šè­°ã®ä¸»ãªè­°è«–å†…å®¹ï¼‰
- æœç¤¼ã§è©±ã—åˆã‚ã‚ŒãŸä¸»è¦ãªè­°é¡Œ
- å…ç«¥ã®ä½“èª¿ãƒ»æ§˜å­å ±å‘Šã€æ¥­å‹™é€£çµ¡ã€å•é¡Œæèµ·ãªã©
- è­°è«–ã•ã‚ŒãŸå†…å®¹ã®æ¦‚è¦ã¨çµè«–
- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¢ã‚¤ãƒ†ãƒ ã‚„ä»Šå¾Œã®å¯¾å¿œæ–¹é‡
- ã€åˆ†é¡åŸºæº–ã€‘: ã€Œï½ã«ã¤ã„ã¦è©±ã—åˆã£ãŸã€ã€Œï½ã®å ±å‘Šã€ã€Œï½ã®æ¤œè¨ã€ãªã©ã®è¡¨ç¾

ğŸ”· **æ±ºå®šäº‹é …**ï¼ˆåˆæ„å½¢æˆã•ã‚ŒãŸå…·ä½“çš„ãªæ±ºå®šï¼‰
- ä¼šè­°ã§æ±ºå®šã•ã‚ŒãŸäº‹é …
- æ–¹é‡æ±ºå®šã€æ‹…å½“è€…æ±ºå®šã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«æ±ºå®šãªã©
- ã€åˆ†é¡åŸºæº–ã€‘: ã€Œæ±ºå®šã—ãŸã€ã€Œï½ã™ã‚‹ã“ã¨ã«ãªã£ãŸã€ã€Œï½ã‚’æ‹…å½“ã™ã‚‹ã€ã€Œï½ã«æ±ºã¾ã£ãŸã€ãªã©ã®è¡¨ç¾
- ã€é™¤å¤–ã€‘: å˜ãªã‚‹å…±æœ‰æƒ…å ±ã‚„å ±å‘Šäº‹é …

ğŸ”· **å…±æœ‰äº‹é …**ï¼ˆã‚¹ã‚¿ãƒƒãƒ•é–“ã§å‘¨çŸ¥ã™ã¹ãæƒ…å ±ï¼‰
- å…¨ã‚¹ã‚¿ãƒƒãƒ•ã¸ã®é€£çµ¡äº‹é …ã€æ³¨æ„å–šèµ·
- æ–½è¨­å…¨ä½“ã®ãƒ«ãƒ¼ãƒ«å¤‰æ›´ã€å¤–éƒ¨ã‹ã‚‰ã®é€£çµ¡
- ãƒ’ãƒ¤ãƒªãƒãƒƒãƒˆäº‹ä¾‹ã€å®‰å…¨ç®¡ç†æƒ…å ±
- ã€åˆ†é¡åŸºæº–ã€‘: ã€Œå…±æœ‰ã—ã¦ãã ã•ã„ã€ã€Œæ³¨æ„ã—ã¦ãã ã•ã„ã€ã€Œå…¨å“¡ã«é€£çµ¡ã€ã€Œï½ã«ã¤ã„ã¦ãŠçŸ¥ã‚‰ã›ã€ãªã©ã®è¡¨ç¾

ğŸ”· **ãã®ä»–ãƒ¡ãƒ¢**ï¼ˆã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å½¢å¼ã®ä¼šè­°ã®æµã‚Œï¼‰
- ä¼šè­°ã®æ™‚ç³»åˆ—çš„ãªæµã‚Œ
- å„è©±é¡Œã®é–‹å§‹æ™‚é–“ã¨æ¦‚è¦
- ç™ºè¨€è€…ã®æƒ…å ±ï¼ˆå¯èƒ½ã§ã‚ã‚Œã°ï¼‰
- ã€å½¢å¼ã€‘: ä»¥ä¸‹ã®Markdownè¡¨å½¢å¼
|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|
|:---|:---|:---|
|00:00|è©±é¡Œ1|å‚™è€ƒ1|
|00:05|è©±é¡Œ2|å‚™è€ƒ2|

ã€å‡ºåŠ›è¦ä»¶ã€‘:
- å„ã‚«ãƒ†ã‚´ãƒªã®å†…å®¹ã‚’MECEåŸå‰‡ã§æ•´ç†ï¼ˆé‡è¤‡ãªãã€æ¼ã‚Œãªãï¼‰
- é‡è¦ãªæƒ…å ±ã‚’è¦‹è½ã¨ã•ãªã„ã‚ˆã†å¾¹åº•çš„ã«åˆ†æ
- ä¿è‚²åœ’é‹å–¶ã«å¿…è¦ãªå®Ÿå‹™çš„ãªå†…å®¹ã‚’å„ªå…ˆ
- æŠ½è±¡çš„ãªè¡¨ç¾ã§ã¯ãªãã€å…·ä½“çš„ãƒ»å®Ÿè·µçš„ãªè¨˜è¿°
- JSONå½¢å¼ã®ã¿ã‚’å‡ºåŠ›ï¼ˆèª¬æ˜æ–‡ä¸è¦ï¼‰

ã€JSONå‡ºåŠ›å½¢å¼ã€‘:
{{
    "è­°é¡Œãƒ»å†…å®¹": "ä¼šè­°ã®ä¸»è¦ãªè­°è«–å†…å®¹ã‚’æ§‹é€ åŒ–ã—ã¦è¨˜è¿°\\n\\nã€å…ç«¥ã®æ§˜å­ã€‘\\n- å…ç«¥A: ä½“èª¿è‰¯å¥½ã€å­¦ç¿’æ„æ¬²é«˜ã„\\n- å…ç«¥B: é¢¨é‚ªæ°—å‘³ã€æ—©é€€äºˆå®š\\n\\nã€æ¥­å‹™é€£çµ¡ã€‘\\n- æ˜æ—¥ã®é€è¿æ‹…å½“å¤‰æ›´\\n- æ–°ã—ã„æ•™æã®å°å…¥æ¤œè¨\\n\\nã€å•é¡Œè§£æ±ºã€‘\\n- é§è»Šå ´æ··é›‘æ™‚ã®å¯¾å¿œç­–è­°è«–",
    "æ±ºå®šäº‹é …": "- æ˜æ—¥ã®é€è¿æ‹…å½“ï¼šç”°ä¸­ã•ã‚“â†’éˆ´æœ¨ã•ã‚“ã«å¤‰æ›´\\n- æ–°æ•™æã®å°å…¥ï¼šæ¥æœˆã‹ã‚‰è©¦é¨“é‹ç”¨\\n- é§è»Šå ´å¯¾ç­–ï¼šäºˆç´„åˆ¶å°å…¥ã‚’æ±ºå®š",
    "å…±æœ‰äº‹é …": "- ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚¶æ³¨æ„å ±ç™ºä»¤ä¸­\\n- æ¥é€±ã®ä¿è­·è€…ä¼šé–‹å‚¬ã®ãŠçŸ¥ã‚‰ã›\\n- ç·Šæ€¥æ™‚ã®é¿é›£çµŒè·¯ç¢ºèªã®ãŠé¡˜ã„\\n- æ–°å…¥è·å“¡ã®æ­“è¿ä¼šã«ã¤ã„ã¦",
    "ãã®ä»–ãƒ¡ãƒ¢": "|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|\\n|:---|:---|:---|\\n|09:00|æœç¤¼é–‹å§‹|å…¨å“¡å‡ºå¸­|\\n|09:05|å…ç«¥æ§˜å­å ±å‘Š|å„æ‹…å½“è€…ã‚ˆã‚Š|\\n|09:15|æ¥­å‹™é€£çµ¡|é€è¿æ‹…å½“å¤‰æ›´ã«ã¤ã„ã¦|\\n|09:25|å…±æœ‰äº‹é …|ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚¶æ³¨æ„å ±|\\n|09:35|ãã®ä»–è­°é¡Œ|æ–°æ•™æå°å…¥æ¤œè¨|\\n|09:45|æœç¤¼çµ‚äº†|æ¬¡å›ã¾ã§ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™|"
}}

ã€é‡è¦ã€‘:
- éŸ³å£°ãƒ†ã‚­ã‚¹ãƒˆã«å«ã¾ã‚Œãªã„æƒ…å ±ã‚’çµ¶å¯¾ã«è¿½åŠ ã—ãªã„
- å„ã‚«ãƒ†ã‚´ãƒªã‚’æ˜ç¢ºã«åŒºåˆ†ã‘ã™ã‚‹
- å®Ÿå‹™çš„ãªå†…å®¹ã‚’å„ªå…ˆã—ã€æŠ½è±¡çš„ãªè¡¨ç¾ã‚’é¿ã‘ã‚‹
- æ—¥æœ¬èªã§è¨˜è¿°ã€JSONå½¢å¼ã®ã¿å‡ºåŠ›
"""
            
            response = model.generate_content(
                prompt,
                generation_config=genai.types.GenerationConfig(
                    temperature=0.3,
                    max_output_tokens=2000
                )
            )
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            import json
            import re
            
            response_text = response.text.strip()
            
            # JSONéƒ¨åˆ†ã‚’æŠ½å‡ºï¼ˆã‚³ãƒ¼ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ãŒã‚ã‚Œã°é™¤å»ï¼‰
            json_match = re.search(r'\{[\s\S]*\}', response_text)
            if json_match:
                json_str = json_match.group(0)
            else:
                json_str = response_text
            
            # JSONã‚’ãƒ‘ãƒ¼ã‚¹
            meeting_data = json.loads(json_str)
            
            # å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ç¢ºèª
            if "è­°é¡Œãƒ»å†…å®¹" not in meeting_data:
                meeting_data["è­°é¡Œãƒ»å†…å®¹"] = text[:500]  # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            
            # ç©ºã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ç©ºæ–‡å­—åˆ—ã«è¨­å®š
            for key in ["æ±ºå®šäº‹é …", "å…±æœ‰äº‹é …", "ãã®ä»–ãƒ¡ãƒ¢"]:
                if key not in meeting_data:
                    meeting_data[key] = ""
            
            return True, meeting_data
            
        except json.JSONDecodeError as e:
            # JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ã®å ´åˆã€ãƒ†ã‚­ã‚¹ãƒˆã‚’ãã®ã¾ã¾è­°é¡Œãƒ»å†…å®¹ã¨ã—ã¦ä½¿ç”¨
            return True, {
                "è­°é¡Œãƒ»å†…å®¹": text[:1000] if len(text) > 1000 else text,
                "æ±ºå®šäº‹é …": "",
                "å…±æœ‰äº‹é …": "",
                "ãã®ä»–ãƒ¡ãƒ¢": ""
            }
        except Exception as e:
            return False, f"è­°äº‹éŒ²ç”Ÿæˆã‚¨ãƒ©ãƒ¼: {str(e)}"

    def _preprocess_meeting_text(self, text: str) -> str:
        """
        ä¼šè­°ãƒ†ã‚­ã‚¹ãƒˆã®å‰å‡¦ç†ã‚’è¡Œã†
        ä¸è¦ãªéƒ¨åˆ†ã®é™¤å»ã€æ•´å½¢ãªã©
        """
        # åŸºæœ¬çš„ãªã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
        cleaned = text.strip()

        # é•·ã™ãã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’é©åˆ‡ã«åˆ†å‰²ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³åˆ¶é™å¯¾ç­–ï¼‰
        if len(cleaned) > 10000:
            # é‡è¦ãªéƒ¨åˆ†ã‚’å„ªå…ˆçš„ã«æ®‹ã™
            sentences = cleaned.split('ã€‚')
            if len(sentences) > 50:
                # æœ€åˆã®30æ–‡ã¨æœ€å¾Œã®20æ–‡ã‚’ä¿æŒ
                cleaned = 'ã€‚'.join(sentences[:30] + sentences[-20:]) + 'ã€‚'

        return cleaned

    def _validate_and_improve_classification(self, original_text: str, analysis_result: Dict[str, str]) -> Dict[str, str]:
        """
        åˆ†é¡çµæœã®æ¤œè¨¼ã¨æ”¹å–„ã‚’è¡Œã†
        """
        try:
            # çµæœã®å“è³ªãƒã‚§ãƒƒã‚¯
            improved_result = analysis_result.copy()

            # è­°é¡Œãƒ»å†…å®¹ã®æ¤œè¨¼
            if not analysis_result.get("è­°é¡Œãƒ»å†…å®¹", "").strip():
                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰ä¸»è¦éƒ¨åˆ†ã‚’æŠ½å‡º
                improved_result["è­°é¡Œãƒ»å†…å®¹"] = original_text[:500]

            # å„ã‚«ãƒ†ã‚´ãƒªã®é‡è¤‡ãƒã‚§ãƒƒã‚¯ã¨æ•´ç†
            all_content = []
            for key in ["è­°é¡Œãƒ»å†…å®¹", "æ±ºå®šäº‹é …", "å…±æœ‰äº‹é …"]:
                content = analysis_result.get(key, "")
                if content and content not in all_content:
                    all_content.append(content)

            # ãã®ä»–ãƒ¡ãƒ¢ã®å½¢å¼ãƒã‚§ãƒƒã‚¯
            notes = analysis_result.get("ãã®ä»–ãƒ¡ãƒ¢", "")
            if notes and not notes.startswith("|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|"):
                # å½¢å¼ãŒæ­£ã—ããªã„å ´åˆã¯ç©ºã«ã™ã‚‹
                improved_result["ãã®ä»–ãƒ¡ãƒ¢"] = ""

            return improved_result

        except Exception as e:
            # ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯å…ƒã®çµæœã‚’è¿”ã™
            return analysis_result

    def validate_meeting_minutes_quality(self, meeting_data: Dict[str, str], original_text: str) -> Dict[str, Any]:
        """
        ç”Ÿæˆã•ã‚ŒãŸè­°äº‹éŒ²ã®å“è³ªã‚’æ¤œè¨¼ã™ã‚‹

        Args:
            meeting_data: ç”Ÿæˆã•ã‚ŒãŸè­°äº‹éŒ²ãƒ‡ãƒ¼ã‚¿
            original_text: å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆ

        Returns:
            å“è³ªæ¤œè¨¼çµæœã®è¾æ›¸
        """
        quality_score = 0
        max_score = 100
        issues = []
        suggestions = []

        try:
            # 1. å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ãƒã‚§ãƒƒã‚¯ (20ç‚¹)
            required_fields = ["è­°é¡Œãƒ»å†…å®¹", "æ±ºå®šäº‹é …", "å…±æœ‰äº‹é …", "ãã®ä»–ãƒ¡ãƒ¢"]
            for field in required_fields:
                if field in meeting_data and meeting_data[field] and meeting_data[field].strip():
                    quality_score += 5
                else:
                    issues.append(f"å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ '{field}' ãŒç©ºã§ã™")
                    suggestions.append(f"'{field}' ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«é©åˆ‡ãªå†…å®¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„")

            # 2. å†…å®¹ã®å¦¥å½“æ€§ãƒã‚§ãƒƒã‚¯ (30ç‚¹)
            content = meeting_data.get("è­°é¡Œãƒ»å†…å®¹", "")
            if content:
                # æ–‡å­—æ•°ãŒé©åˆ‡ã‹ãƒã‚§ãƒƒã‚¯
                if 50 <= len(content) <= 2000:
                    quality_score += 10
                elif len(content) < 50:
                    issues.append("è­°é¡Œãƒ»å†…å®¹ãŒçŸ­ã™ãã¾ã™")
                    suggestions.append("ä¼šè­°ã®ä¸»è¦ãªè­°è«–å†…å®¹ã‚’ã‚ˆã‚Šè©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„")
                else:
                    issues.append("è­°é¡Œãƒ»å†…å®¹ãŒé•·ã™ãã¾ã™")
                    suggestions.append("å†…å®¹ã‚’ç°¡æ½”ã«æ•´ç†ã—ã¦ãã ã•ã„")

                # ä¿è‚²åœ’é–¢é€£ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                childcare_keywords = ["å…ç«¥", "å­ä¾›", "åœ’å…", "ä¿è­·è€…", "é€è¿", "å­¦ç¿’", "éŠã³", "ä½“èª¿", "å®‰å…¨", "ãƒ’ãƒ¤ãƒªãƒãƒƒãƒˆ"]
                keyword_count = sum(1 for keyword in childcare_keywords if keyword in content)
                if keyword_count >= 2:
                    quality_score += 10
                elif keyword_count == 0:
                    issues.append("ä¿è‚²åœ’é‹å–¶ã«é–¢é€£ã™ã‚‹å†…å®¹ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
                    suggestions.append("å…ç«¥ã®æ§˜å­ã€æ¥­å‹™é€£çµ¡ã€å®‰å…¨ç®¡ç†ãªã©ã®ä¿è‚²åœ’ç‰¹æœ‰ã®å†…å®¹ã‚’å«ã‚ã¦ãã ã•ã„")

                # MECEåŸå‰‡ã®ãƒã‚§ãƒƒã‚¯ï¼ˆé‡è¤‡ãŒãªã„ã‹ï¼‰
                if len(content.split("ã€‚")) >= 3:  # æœ€ä½3ã¤ã®æ–‡ãŒã‚ã‚‹
                    quality_score += 10

            # 3. åˆ†é¡ã®é©åˆ‡æ€§ãƒã‚§ãƒƒã‚¯ (25ç‚¹)
            # æ±ºå®šäº‹é …ã¨å…±æœ‰äº‹é …ãŒæ··åœ¨ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
            decisions = meeting_data.get("æ±ºå®šäº‹é …", "")
            shared = meeting_data.get("å…±æœ‰äº‹é …", "")

            if decisions and shared:
                # æ±ºå®šäº‹é …ã«ã€Œå…±æœ‰ã€ã®è¡¨ç¾ãŒå…¥ã£ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                if not any(word in decisions.lower() for word in ["å…±æœ‰", "é€£çµ¡", "ãŠçŸ¥ã‚‰ã›"]):
                    quality_score += 10
                else:
                    issues.append("æ±ºå®šäº‹é …ã«å…±æœ‰äº‹é …ãŒæ··åœ¨ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
                    suggestions.append("æ±ºå®šäº‹é …ã¨å…±æœ‰äº‹é …ã‚’æ˜ç¢ºã«åˆ†é›¢ã—ã¦ãã ã•ã„")

                # å…±æœ‰äº‹é …ã«ã€Œæ±ºå®šã€ã®è¡¨ç¾ãŒå…¥ã£ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯
                if not any(word in shared.lower() for word in ["æ±ºå®š", "ï½ã™ã‚‹", "æ‹…å½“"]):
                    quality_score += 10
                else:
                    issues.append("å…±æœ‰äº‹é …ã«æ±ºå®šäº‹é …ãŒæ··åœ¨ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™")
                    suggestions.append("å…±æœ‰äº‹é …ã¨æ±ºå®šäº‹é …ã‚’æ˜ç¢ºã«åˆ†é›¢ã—ã¦ãã ã•ã„")

            # 4. ãã®ä»–ãƒ¡ãƒ¢ã®å½¢å¼ãƒã‚§ãƒƒã‚¯ (15ç‚¹)
            notes = meeting_data.get("ãã®ä»–ãƒ¡ãƒ¢", "")
            if notes:
                if notes.startswith("|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|"):
                    quality_score += 15
                else:
                    issues.append("ãã®ä»–ãƒ¡ãƒ¢ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“")
                    suggestions.append("ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¡¨å½¢å¼ï¼ˆ|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|ï¼‰ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„")

            # 5. å…¨ä½“çš„ä¸€è²«æ€§ãƒã‚§ãƒƒã‚¯ (10ç‚¹)
            total_content_length = sum(len(meeting_data.get(field, "")) for field in required_fields)
            if total_content_length >= 200:
                quality_score += 10
            else:
                issues.append("å…¨ä½“ã®è¨˜è¿°é‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™")
                suggestions.append("å„é …ç›®ã‚’ã‚ˆã‚Šè©³ç´°ã«è¨˜è¿°ã—ã¦ãã ã•ã„")

            # å“è³ªãƒ¬ãƒ™ãƒ«åˆ¤å®š
            if quality_score >= 90:
                quality_level = "å„ªç§€"
            elif quality_score >= 75:
                quality_level = "è‰¯å¥½"
            elif quality_score >= 60:
                quality_level = "å¯"
            else:
                quality_level = "è¦æ”¹å–„"

            return {
                "quality_score": quality_score,
                "max_score": max_score,
                "quality_level": quality_level,
                "issues": issues,
                "suggestions": suggestions,
                "details": {
                    "content_length": len(content),
                    "has_required_fields": all(field in meeting_data and meeting_data[field].strip() for field in required_fields),
                    "keyword_count": keyword_count if 'keyword_count' in locals() else 0,
                    "has_proper_format": notes.startswith("|ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—|è©±é¡Œ|å‚™è€ƒ|") if notes else False
                }
            }

        except Exception as e:
            return {
                "quality_score": 0,
                "max_score": max_score,
                "quality_level": "è©•ä¾¡ã‚¨ãƒ©ãƒ¼",
                "issues": [f"å“è³ªè©•ä¾¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {str(e)}"],
                "suggestions": ["ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„"],
                "details": {}
            }

